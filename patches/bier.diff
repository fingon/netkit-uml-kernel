diff --new-file -ur linux-3.14.16.old/net/ipv6/Kconfig linux-3.14.16/net/ipv6/Kconfig
--- linux-3.14.16.old/net/ipv6/Kconfig	2014-08-08 02:50:59.000000000 +0300
+++ linux-3.14.16/net/ipv6/Kconfig	2015-03-22 19:40:17.116182510 +0200
@@ -21,6 +21,13 @@
 
 if IPV6
 
+config IPV6_BIER
+	tristate "IPv6: BIER forwarding support"
+        default m
+	---help---
+	  Using the _set_ bits 32 .. 47 in the IPv6 multicast address,
+	  do unicast routing based forwarding.
+
 config IPV6_ROUTER_PREF
 	bool "IPv6: Router Preference (RFC 4191) support"
 	---help---
diff --new-file -ur linux-3.14.16.old/net/ipv6/Kconfig~ linux-3.14.16/net/ipv6/Kconfig~
--- linux-3.14.16.old/net/ipv6/Kconfig~	1970-01-01 02:00:00.000000000 +0200
+++ linux-3.14.16/net/ipv6/Kconfig~	2014-08-08 02:50:59.000000000 +0300
@@ -0,0 +1,261 @@
+#
+# IPv6 configuration
+#
+
+#   IPv6 as module will cause a CRASH if you try to unload it
+menuconfig IPV6
+	tristate "The IPv6 protocol"
+	default m
+	---help---
+	  This is complemental support for the IP version 6.
+	  You will still be able to do traditional IPv4 networking as well.
+
+	  For general information about IPv6, see
+	  <https://en.wikipedia.org/wiki/IPv6>.
+	  For Linux IPv6 development information, see <http://www.linux-ipv6.org>.
+	  For specific information about IPv6 under Linux, read the HOWTO at
+	  <http://www.bieringer.de/linux/IPv6/>.
+
+	  To compile this protocol support as a module, choose M here: the 
+	  module will be called ipv6.
+
+if IPV6
+
+config IPV6_ROUTER_PREF
+	bool "IPv6: Router Preference (RFC 4191) support"
+	---help---
+	  Router Preference is an optional extension to the Router
+	  Advertisement message which improves the ability of hosts
+	  to pick an appropriate router, especially when the hosts
+	  are placed in a multi-homed network.
+
+	  If unsure, say N.
+
+config IPV6_ROUTE_INFO
+	bool "IPv6: Route Information (RFC 4191) support"
+	depends on IPV6_ROUTER_PREF
+	---help---
+	  This is experimental support of Route Information.
+
+	  If unsure, say N.
+
+config IPV6_OPTIMISTIC_DAD
+	bool "IPv6: Enable RFC 4429 Optimistic DAD"
+	---help---
+	  This is experimental support for optimistic Duplicate
+	  Address Detection.  It allows for autoconfigured addresses
+	  to be used more quickly.
+
+	  If unsure, say N.
+
+config INET6_AH
+	tristate "IPv6: AH transformation"
+	select XFRM_ALGO
+	select CRYPTO
+	select CRYPTO_HMAC
+	select CRYPTO_MD5
+	select CRYPTO_SHA1
+	---help---
+	  Support for IPsec AH.
+
+	  If unsure, say Y.
+
+config INET6_ESP
+	tristate "IPv6: ESP transformation"
+	select XFRM_ALGO
+	select CRYPTO
+	select CRYPTO_AUTHENC
+	select CRYPTO_HMAC
+	select CRYPTO_MD5
+	select CRYPTO_CBC
+	select CRYPTO_SHA1
+	select CRYPTO_DES
+	---help---
+	  Support for IPsec ESP.
+
+	  If unsure, say Y.
+
+config INET6_IPCOMP
+	tristate "IPv6: IPComp transformation"
+	select INET6_XFRM_TUNNEL
+	select XFRM_IPCOMP
+	---help---
+	  Support for IP Payload Compression Protocol (IPComp) (RFC3173),
+	  typically needed for IPsec.
+
+	  If unsure, say Y.
+
+config IPV6_MIP6
+	tristate "IPv6: Mobility"
+	select XFRM
+	---help---
+	  Support for IPv6 Mobility described in RFC 3775.
+
+	  If unsure, say N.
+
+config INET6_XFRM_TUNNEL
+	tristate
+	select INET6_TUNNEL
+	default n
+
+config INET6_TUNNEL
+	tristate
+	default n
+
+config INET6_XFRM_MODE_TRANSPORT
+	tristate "IPv6: IPsec transport mode"
+	default IPV6
+	select XFRM
+	---help---
+	  Support for IPsec transport mode.
+
+	  If unsure, say Y.
+
+config INET6_XFRM_MODE_TUNNEL
+	tristate "IPv6: IPsec tunnel mode"
+	default IPV6
+	select XFRM
+	---help---
+	  Support for IPsec tunnel mode.
+
+	  If unsure, say Y.
+
+config INET6_XFRM_MODE_BEET
+	tristate "IPv6: IPsec BEET mode"
+	default IPV6
+	select XFRM
+	---help---
+	  Support for IPsec BEET mode.
+
+	  If unsure, say Y.
+
+config INET6_XFRM_MODE_ROUTEOPTIMIZATION
+	tristate "IPv6: MIPv6 route optimization mode"
+	select XFRM
+	---help---
+	  Support for MIPv6 route optimization mode.
+
+config IPV6_VTI
+tristate "Virtual (secure) IPv6: tunneling"
+	select IPV6_TUNNEL
+	select NET_IP_TUNNEL
+	depends on INET6_XFRM_MODE_TUNNEL
+	---help---
+	Tunneling means encapsulating data of one protocol type within
+	another protocol and sending it over a channel that understands the
+	encapsulating protocol. This can be used with xfrm mode tunnel to give
+	the notion of a secure tunnel for IPSEC and then use routing protocol
+	on top.
+
+config IPV6_SIT
+	tristate "IPv6: IPv6-in-IPv4 tunnel (SIT driver)"
+	select INET_TUNNEL
+	select NET_IP_TUNNEL
+	select IPV6_NDISC_NODETYPE
+	default y
+	---help---
+	  Tunneling means encapsulating data of one protocol type within
+	  another protocol and sending it over a channel that understands the
+	  encapsulating protocol. This driver implements encapsulation of IPv6
+	  into IPv4 packets. This is useful if you want to connect two IPv6
+	  networks over an IPv4-only path.
+
+	  Saying M here will produce a module called sit. If unsure, say Y.
+
+config IPV6_SIT_6RD
+	bool "IPv6: IPv6 Rapid Deployment (6RD)"
+	depends on IPV6_SIT
+	default n
+	---help---
+	  IPv6 Rapid Deployment (6rd; draft-ietf-softwire-ipv6-6rd) builds upon
+	  mechanisms of 6to4 (RFC3056) to enable a service provider to rapidly
+	  deploy IPv6 unicast service to IPv4 sites to which it provides
+	  customer premise equipment.  Like 6to4, it utilizes stateless IPv6 in
+	  IPv4 encapsulation in order to transit IPv4-only network
+	  infrastructure.  Unlike 6to4, a 6rd service provider uses an IPv6
+	  prefix of its own in place of the fixed 6to4 prefix.
+
+	  With this option enabled, the SIT driver offers 6rd functionality by
+	  providing additional ioctl API to configure the IPv6 Prefix for in
+	  stead of static 2002::/16 for 6to4.
+
+	  If unsure, say N.
+
+config IPV6_NDISC_NODETYPE
+	bool
+
+config IPV6_TUNNEL
+	tristate "IPv6: IP-in-IPv6 tunnel (RFC2473)"
+	select INET6_TUNNEL
+	---help---
+	  Support for IPv6-in-IPv6 and IPv4-in-IPv6 tunnels described in
+	  RFC 2473.
+
+	  If unsure, say N.
+
+config IPV6_GRE
+	tristate "IPv6: GRE tunnel"
+	select IPV6_TUNNEL
+	select NET_IP_TUNNEL
+	---help---
+	  Tunneling means encapsulating data of one protocol type within
+	  another protocol and sending it over a channel that understands the
+	  encapsulating protocol. This particular tunneling driver implements
+	  GRE (Generic Routing Encapsulation) and at this time allows
+	  encapsulating of IPv4 or IPv6 over existing IPv6 infrastructure.
+	  This driver is useful if the other endpoint is a Cisco router: Cisco
+	  likes GRE much better than the other Linux tunneling driver ("IP
+	  tunneling" above). In addition, GRE allows multicast redistribution
+	  through the tunnel.
+
+	  Saying M here will produce a module called ip6_gre. If unsure, say N.
+
+config IPV6_MULTIPLE_TABLES
+	bool "IPv6: Multiple Routing Tables"
+	select FIB_RULES
+	---help---
+	  Support multiple routing tables.
+
+config IPV6_SUBTREES
+	bool "IPv6: source address based routing"
+	depends on IPV6_MULTIPLE_TABLES
+	---help---
+	  Enable routing by source address or prefix.
+
+	  The destination address is still the primary routing key, so mixing
+	  normal and source prefix specific routes in the same routing table
+	  may sometimes lead to unintended routing behavior.  This can be
+	  avoided by defining different routing tables for the normal and
+	  source prefix specific routes.
+
+	  If unsure, say N.
+
+config IPV6_MROUTE
+	bool "IPv6: multicast routing"
+	depends on IPV6
+	---help---
+	  Experimental support for IPv6 multicast forwarding.
+	  If unsure, say N.
+
+config IPV6_MROUTE_MULTIPLE_TABLES
+	bool "IPv6: multicast policy routing"
+	depends on IPV6_MROUTE
+	select FIB_RULES
+	help
+	  Normally, a multicast router runs a userspace daemon and decides
+	  what to do with a multicast packet based on the source and
+	  destination addresses. If you say Y here, the multicast router
+	  will also be able to take interfaces and packet marks into
+	  account and run multiple instances of userspace daemons
+	  simultaneously, each one handling a single table.
+
+	  If unsure, say N.
+
+config IPV6_PIMSM_V2
+	bool "IPv6: PIM-SM version 2 support"
+	depends on IPV6_MROUTE
+	---help---
+	  Support for IPv6 PIM multicast routing protocol PIM-SMv2.
+	  If unsure, say N.
+
+endif # IPV6
diff --new-file -ur linux-3.14.16.old/net/ipv6/Makefile linux-3.14.16/net/ipv6/Makefile
--- linux-3.14.16.old/net/ipv6/Makefile	2014-08-08 02:50:59.000000000 +0300
+++ linux-3.14.16/net/ipv6/Makefile	2015-03-22 17:52:54.892536362 +0200
@@ -36,6 +36,7 @@
 obj-$(CONFIG_IPV6_MIP6) += mip6.o
 obj-$(CONFIG_NETFILTER)	+= netfilter/
 
+obj-$(CONFIG_IPV6_BIER) += bier.o
 obj-$(CONFIG_IPV6_VTI) += ip6_vti.o
 obj-$(CONFIG_IPV6_SIT) += sit.o
 obj-$(CONFIG_IPV6_TUNNEL) += ip6_tunnel.o
diff --new-file -ur linux-3.14.16.old/net/ipv6/Makefile~ linux-3.14.16/net/ipv6/Makefile~
--- linux-3.14.16.old/net/ipv6/Makefile~	1970-01-01 02:00:00.000000000 +0200
+++ linux-3.14.16/net/ipv6/Makefile~	2014-08-08 02:50:59.000000000 +0300
@@ -0,0 +1,47 @@
+#
+# Makefile for the Linux TCP/IP (INET6) layer.
+#
+
+obj-$(CONFIG_IPV6) += ipv6.o
+
+ipv6-objs :=	af_inet6.o anycast.o ip6_output.o ip6_input.o addrconf.o \
+		addrlabel.o \
+		route.o ip6_fib.o ipv6_sockglue.o ndisc.o udp.o udplite.o \
+		raw.o icmp.o mcast.o reassembly.o tcp_ipv6.o ping.o \
+		exthdrs.o datagram.o ip6_flowlabel.o inet6_connection_sock.o
+
+ipv6-offload :=	ip6_offload.o tcpv6_offload.o udp_offload.o exthdrs_offload.o
+
+ipv6-$(CONFIG_SYSCTL) = sysctl_net_ipv6.o
+ipv6-$(CONFIG_IPV6_MROUTE) += ip6mr.o
+
+ipv6-$(CONFIG_XFRM) += xfrm6_policy.o xfrm6_state.o xfrm6_input.o \
+	xfrm6_output.o
+ipv6-$(CONFIG_NETFILTER) += netfilter.o
+ipv6-$(CONFIG_IPV6_MULTIPLE_TABLES) += fib6_rules.o
+ipv6-$(CONFIG_PROC_FS) += proc.o
+ipv6-$(CONFIG_SYN_COOKIES) += syncookies.o
+
+ipv6-objs += $(ipv6-y)
+
+obj-$(CONFIG_INET6_AH) += ah6.o
+obj-$(CONFIG_INET6_ESP) += esp6.o
+obj-$(CONFIG_INET6_IPCOMP) += ipcomp6.o
+obj-$(CONFIG_INET6_XFRM_TUNNEL) += xfrm6_tunnel.o
+obj-$(CONFIG_INET6_TUNNEL) += tunnel6.o
+obj-$(CONFIG_INET6_XFRM_MODE_TRANSPORT) += xfrm6_mode_transport.o
+obj-$(CONFIG_INET6_XFRM_MODE_TUNNEL) += xfrm6_mode_tunnel.o
+obj-$(CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION) += xfrm6_mode_ro.o
+obj-$(CONFIG_INET6_XFRM_MODE_BEET) += xfrm6_mode_beet.o
+obj-$(CONFIG_IPV6_MIP6) += mip6.o
+obj-$(CONFIG_NETFILTER)	+= netfilter/
+
+obj-$(CONFIG_IPV6_VTI) += ip6_vti.o
+obj-$(CONFIG_IPV6_SIT) += sit.o
+obj-$(CONFIG_IPV6_TUNNEL) += ip6_tunnel.o
+obj-$(CONFIG_IPV6_GRE) += ip6_gre.o
+
+obj-y += addrconf_core.o exthdrs_core.o ip6_checksum.o ip6_icmp.o
+obj-$(CONFIG_INET) += output_core.o protocol.o $(ipv6-offload)
+
+obj-$(subst m,y,$(CONFIG_IPV6)) += inet6_hashtables.o
diff --new-file -ur linux-3.14.16.old/net/ipv6/bier.c linux-3.14.16/net/ipv6/bier.c
--- linux-3.14.16.old/net/ipv6/bier.c	1970-01-01 02:00:00.000000000 +0200
+++ linux-3.14.16/net/ipv6/bier.c	2015-03-22 21:46:23.455122098 +0200
@@ -0,0 +1,181 @@
+/*
+ * $Id: bier.c $
+ *
+ * Author: Markus Stenberg <fingon@iki.fi>
+ *
+ * Copyright (c) 2015 Markus Stenberg
+ *
+ * Created:       Sun Mar 22 17:53:27 2015 mstenber
+ * Last modified: Sun Mar 22 21:46:23 2015 mstenber
+ * Edit time:     97 min
+ *
+ */
+
+/*
+ * This is rather simple ~demonstration code for BIER forwarding.
+ * Basic idea:
+ *
+ * - match only IPv6 multicast packets with non-zero bits in second
+ *   32-bit word.
+ *
+ * - use those bits to select forwarding targets (for homenet
+ *   purposes, this is just amusement value project)
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/skbuff.h>
+#include <linux/ip.h>
+#include <linux/ipv6.h>
+#include <linux/netfilter.h>
+#include <net/ip6_route.h>
+
+MODULE_AUTHOR("Markus Stenberg");
+MODULE_DESCRIPTION("Simple BIER forwarder for homenet purposes");
+MODULE_LICENSE("GPL");
+
+static u32 bid;
+module_param(bid, uint, 0400);
+MODULE_PARM_DESC(bid, "Local BIER identifier");
+
+#define MAX_NUM_BIER_NODES 32
+
+static char *biarr[MAX_NUM_BIER_NODES];
+static unsigned int biarr_c;
+module_param_array(biarr, charp, &biarr_c, 0400);
+MODULE_PARM_DESC(biarr, "BIER address parameter array");
+
+static struct in6_addr biarra[MAX_NUM_BIER_NODES];
+
+static unsigned int
+bier_nf_pre_routing(const struct nf_hook_ops *ops,
+                    struct sk_buff *skb,
+                    const struct net_device *in,
+                    const struct net_device *out,
+                    int (*okfn)(struct sk_buff *))
+{
+  struct ipv6hdr *iph, *iph2;
+  u64 dbid;
+  bool is_local;
+  int i, j;
+  struct sk_buff *skb2;
+  struct rt6_info *rt, *rt2;
+  struct dst_entry *dst;
+  struct neighbour *neigh;
+  struct in6_addr *nexthop;
+
+  iph = ipv6_hdr(skb);
+
+  /* Non-multicast -> not interested */
+  if (iph->daddr.s6_addr[0] != 0xFF)
+    return NF_ACCEPT;
+
+  dbid = iph->daddr.s6_addr32[1];
+
+  /* Not one of the stolen bits */
+  if (!dbid)
+    return NF_ACCEPT;
+
+  is_local = dbid & (1 << bid);
+
+  dbid &= ~(1<<bid);
+
+  /* Look at what copies we need to fork */
+  for (i = 0 ; i < biarr_c ; i++)
+    {
+      u32 cbid = 0;
+      /* Very, very inelegant but oh well. */
+      struct flowi6 fl6 =
+        {
+          .flowi6_oif = skb->sk ? skb->sk->sk_bound_dev_if : 0,
+          .flowi6_mark = skb->mark,
+          .daddr = biarra[i],
+          .saddr = iph->saddr,
+        };
+      if (!(dbid & (1 << i)))
+        continue;
+      rt = rt6_lookup(dev_net(skb->dev), &biarra[i], &iph->saddr, 0, 0);
+
+      for (j = i ; j < biarr_c ; j++)
+        {
+          if (!(dbid & (1 << j)))
+            continue;
+          rt2 = rt6_lookup(dev_net(skb->dev), &biarra[j], &iph->saddr, 0, 0);
+          if (rt == rt2)
+            {
+              dbid &= ~(1 << j);
+              cbid |= 1 << j;
+            }
+          ip6_rt_put(rt2);
+        }
+      skb2 = skb_clone(skb, GFP_ATOMIC);
+      dst = ip6_route_output(dev_net(skb->dev), skb->sk, &fl6);
+      if (dst->error)
+        {
+          printk(KERN_ERR "bier route lookup failure\n");
+          kfree_skb(skb2);
+          continue;
+        }
+
+      skb_dst_drop(skb2);
+
+      skb_dst_set(skb2, dst);
+      skb2->dev = dst->dev;
+
+      iph2 = ipv6_hdr(skb2);
+      iph2->daddr.s6_addr32[1] = cbid;
+
+      /* TBD - is this enough? */
+      printk(KERN_ERR "bier dupe\n");
+      dst->output(skb2);
+
+      ip6_rt_put(rt);
+    }
+
+  if (is_local)
+    {
+      printk(KERN_ERR "bier local accept\n");
+      iph->daddr.s6_addr32[1] = 0;
+      return NF_ACCEPT;
+    }
+  else
+    {
+      printk(KERN_ERR "bier local drop\n");
+      return NF_DROP;
+    }
+}
+
+static struct nf_hook_ops bier_nf_ops[] __read_mostly = {
+  {
+    .hook = bier_nf_pre_routing,
+    .owner = THIS_MODULE,
+    .pf = NFPROTO_IPV6,
+    .hooknum = NF_INET_PRE_ROUTING,
+    .priority = 0
+  },
+};
+
+static int __init bier_init(void)
+{
+  int ret, i;
+  ret = nf_register_hooks(bier_nf_ops, ARRAY_SIZE(bier_nf_ops));
+  if (ret < 0)
+    return ret;
+  for (i = 0 ; i < biarr_c ; i++)
+    {
+      if (strlen(biarr[i]) != 32)
+        return -1;
+      if (hex2bin((u8 *)&biarra[i], biarr[i], 16) < 0)
+        return -1;
+    }
+  printk(KERN_ERR "bier loaded with %d\n", biarr_c);
+  return 0;
+}
+
+static void __exit bier_exit(void)
+{
+  nf_unregister_hooks(bier_nf_ops, ARRAY_SIZE(bier_nf_ops));
+}
+
+module_init(bier_init);
+module_exit(bier_exit);
diff --new-file -ur linux-3.14.16.old/net/ipv6/bier.c~ linux-3.14.16/net/ipv6/bier.c~
--- linux-3.14.16.old/net/ipv6/bier.c~	1970-01-01 02:00:00.000000000 +0200
+++ linux-3.14.16/net/ipv6/bier.c~	2015-03-22 17:53:30.167870863 +0200
@@ -0,0 +1,13 @@
+/*
+ * $Id: bier.c $
+ *
+ * Author: Markus Stenberg <fingon@iki.fi>
+ *
+ * Copyright (c) 2015 Markus Stenberg
+ *
+ * Created:       Sun Mar 22 17:53:27 2015 mstenber
+ * Last modified: Sun Mar 22 17:53:30 2015 mstenber
+ * Edit time:     1 min
+ *
+ */
+
